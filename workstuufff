
import pandas as pd
import numpy as np

def simple_aggregation_options(df_all):
    """
    Different ways to aggregate df_all directly to country-product-date level
    without using account-level weighting
    """
    
    print("="*60)
    print("DIRECT AGGREGATION OPTIONS (No Account Weighting)")
    print("="*60)
    
    # Option 1: Simple Average (Equal Weight to All Segments)
    print("Option 1: Simple Average Aggregation")
    simple_avg = df_all.groupby(['cntry_cd', 'prd_cd', 'cal_dt']).agg({
        'fli_perf': 'mean',
        'pd': 'mean',
        'lgd': 'mean',
        'bhvr_score_aligned': 'count'  # Number of segments
    }).reset_index()
    simple_avg = simple_avg.rename(columns={'bhvr_score_aligned': 'segment_count'})
    
    print(f"Result shape: {simple_avg.shape}")
    print("Sample:")
    print(simple_avg.head())
    
    # Option 2: Weighted by Record Count (if some segments have more records)
    print(f"\nOption 2: Count-Weighted Aggregation")
    count_weighted = df_all.groupby(['cntry_cd', 'prd_cd', 'cal_dt', 'bus_entity', 'pd_seg', 'bhvr_score_aligned']).agg({
        'fli_perf': 'mean'
    }).reset_index()
    
    # Then aggregate again, weighting by count of records in each segment
    count_agg = count_weighted.groupby(['cntry_cd', 'prd_cd', 'cal_dt']).agg({
        'fli_perf': 'mean'  # This gives equal weight to each segment
    }).reset_index()
    
    print(f"Result shape: {count_agg.shape}")
    
    # Option 3: Median Aggregation (Robust to Outliers)
    print(f"\nOption 3: Median Aggregation")
    median_agg = df_all.groupby(['cntry_cd', 'prd_cd', 'cal_dt']).agg({
        'fli_perf': 'median',
        'pd': 'median',
        'lgd': 'median',
        'bhvr_score_aligned': 'count'
    }).reset_index()
    median_agg = median_agg.rename(columns={'bhvr_score_aligned': 'segment_count'})
    
    print(f"Result shape: {median_agg.shape}")
    
    # Option 4: Statistical Summary (Multiple Metrics)
    print(f"\nOption 4: Statistical Summary")
    stats_agg = df_all.groupby(['cntry_cd', 'prd_cd', 'cal_dt']).agg({
        'fli_perf': ['mean', 'median', 'std', 'min', 'max', 'count']
    }).reset_index()
    
    # Flatten column names
    stats_agg.columns = [
        'cntry_cd', 'prd_cd', 'cal_dt',
        'fli_perf_mean', 'fli_perf_median', 'fli_perf_std', 
        'fli_perf_min', 'fli_perf_max', 'segment_count'
    ]
    
    print(f"Result shape: {stats_agg.shape}")
    print("Sample:")
    print(stats_agg.head())
    
    return {
        'simple_average': simple_avg,
        'count_weighted': count_agg,
        'median': median_agg,
        'statistical_summary': stats_agg
    }

def compare_aggregation_methods(df_all):
    """
    Compare different aggregation methods
    """
    
    print("\n" + "="*60)
    print("COMPARISON OF AGGREGATION METHODS")
    print("="*60)
    
    # Get all methods
    results = simple_aggregation_options(df_all)
    
    # Merge for comparison
    comparison = results['simple_average'][['cntry_cd', 'prd_cd', 'cal_dt', 'fli_perf']].rename(columns={'fli_perf': 'mean_fli'})
    comparison = comparison.merge(
        results['median'][['cntry_cd', 'prd_cd', 'cal_dt', 'fli_perf']].rename(columns={'fli_perf': 'median_fli'}),
        on=['cntry_cd', 'prd_cd', 'cal_dt']
    )
    
    # Calculate differences
    comparison['mean_vs_median_diff'] = comparison['mean_fli'] - comparison['median_fli']
    comparison['mean_vs_median_pct'] = (comparison['mean_vs_median_diff'] / comparison['mean_fli']) * 100
    
    print("Mean vs Median Comparison:")
    print(comparison[['cntry_cd', 'prd_cd', 'cal_dt', 'mean_fli', 'median_fli', 'mean_vs_median_pct']].head())
    
    print(f"\nSummary Statistics:")
    print(f"Mean absolute difference: {comparison['mean_vs_median_diff'].abs().mean():.6f}")
    print(f"Max difference: {comparison['mean_vs_median_diff'].abs().max():.6f}")
    print(f"Mean absolute % difference: {comparison['mean_vs_median_pct'].abs().mean():.2f}%")
    
    return comparison

def recommended_simple_approach(df_all):
    """
    Recommended simple approach - most commonly used in practice
    """
    
    print("\n" + "="*60)
    print("RECOMMENDED SIMPLE APPROACH")
    print("="*60)
    
    # Simple mean aggregation with additional metrics for context
    final_result = df_all.groupby(['cntry_cd', 'prd_cd', 'cal_dt']).agg({
        'fli_perf': ['mean', 'std', 'count'],
        'pd': 'mean',
        'lgd': 'mean'
    }).reset_index()
    
    # Flatten columns
    final_result.columns = [
        'cntry_cd', 'prd_cd', 'cal_dt',
        'fli_perf_mean', 'fli_perf_std', 'segment_count',
        'avg_pd', 'avg_lgd'
    ]
    
    # Add coefficient of variation for variability assessment
    final_result['fli_perf_cv'] = final_result['fli_perf_std'] / final_result['fli_perf_mean']
    
    print("Final aggregated dataset:")
    print(f"Shape: {final_result.shape}")
    print("\nSample:")
    print(final_result[['cntry_cd', 'prd_cd', 'cal_dt', 'fli_perf_mean', 'segment_count', 'fli_perf_cv']].head())
    
    print(f"\nData Summary:")
    print(f"- Date range: {final_result['cal_dt'].min()} to {final_result['cal_dt'].max()}")
    print(f"- Countries: {final_result['cntry_cd'].nunique()}")
    print(f"- Products: {final_result['prd_cd'].nunique()}")
    print(f"- Average segments per country-product-date: {final_result['segment_count'].mean():.1f}")
    
    return final_result

# Example usage functions
def export_simple_results(result, filename='simple_aggregated_fli.csv'):
    """Export results to CSV"""
    result.to_csv(filename, index=False)
    print(f"Results exported to: {filename}")

# Main execution function
def main_simple_aggregation(df_all):
    """
    Main function for simple aggregation without account weighting
    """
    
    print("DIRECT AGGREGATION OF df_all (NO ACCOUNT WEIGHTING)")
    print("="*60)
    print(f"Input data shape: {df_all.shape}")
    
    # Show all options
    all_results = simple_aggregation_options(df_all)
    
    # Compare methods
    comparison = compare_aggregation_methods(df_all)
    
    # Get recommended result
    final_result = recommended_simple_approach(df_all)
    
    print(f"\n" + "="*60)
    print("SUMMARY")
    print("="*60)
    print("✅ Simple aggregation complete!")
    print("✅ Your FLI performance is now at country-product-date level")
    print("✅ Uses equal weighting for all segments (standard approach)")
    print(f"✅ Final dataset: {final_result.shape[0]} records")
    
    return final_result, all_results, comparison

# Quick one-liner for immediate use
def quick_aggregate(df_all):
    """One-line aggregation for immediate use"""
    return df_all.groupby(['cntry_cd', 'prd_cd', 'cal_dt'])['fli_perf'].mean().reset_index()

# Usage examples:
"""
# Option 1: Quick and simple
result = quick_aggregate(df_all)

# Option 2: Full analysis with multiple methods
final_result, all_methods, comparison = main_simple_aggregation(df_all)

# Option 3: Just get the recommended approach
recommended_result = recommended_simple_approach(df_all)
"""
